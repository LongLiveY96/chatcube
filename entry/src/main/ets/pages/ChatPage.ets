import { KeyboardAvoidMode } from '@kit.ArkUI'
import { common } from '@kit.AbilityKit'
import {
  ChatMessage,
  MessageRole,
  ModelProvider,
  ModelInfo,
  MessageAttachment,
  ReasoningLevel,
  ModelRole
} from '../models/ChatModels'
import { AttachmentPicker } from '../components/AttachmentPicker'
import { ImagePreview } from '../components/ImagePreview'
import { ChatNavigationBar } from '../components/ChatNavigationBar'
import { ScrollToBottomButton } from '../components/ScrollToBottomButton'
import { MultiSelectToolbar } from '../components/MultiSelectToolbar'
import { SharePreviewSheet } from '../components/SharePreviewSheet'
import { ChatViewModel, TitleGenerationCallbacks } from '../viewmodels/ChatViewModel'
import { ProviderViewModel } from '../viewmodels/ProviderViewModel'
import { AppStateManager } from '../viewmodels/AppStateManager'
import { AITaskService } from '../services/AITaskService'
import { WebSearchService } from '../services/WebSearchService'
import { DefaultModelService } from '../services/DefaultModelService'
import { PreferenceKeys, PreferencesService } from '../services/PreferencesService'
import { TTSService } from '../services/TTSService'
import { ToolRegistry } from '../services/ToolRegistry'
import { ServiceRegistry } from '../services/ServiceRegistry'
import { registerBuiltinTools } from '../config/BuiltinTools'
import { AppStorageKeys } from '../config/AppStorageKeys'
import { inputMethod } from '@kit.IMEKit'
import { showSnackBar, SnackBarDisplayOptions, SnackBarTone } from '../utils/ToastUtil'
import { createMessageDataSource, MessageDataSource } from '../datasource/MessageDataSource'
import { hilog } from '@kit.PerformanceAnalysisKit'
import { ChatModelSelectorSheetContent } from '../components/chat/ChatModelSelectorSheetContent'
import { ChatInputAreaSection } from '../components/chat/ChatInputAreaSection'
import { ChatMessageListSection } from '../components/chat/ChatMessageListSection'
import {
  getListBottomPaddingForChat,
  getPreviewTimeTextForChat,
  shouldShowScrollToTopButtonForChat
} from './chat/ChatPageUiHelper'
import { parseToolIdsFromRouteRaw } from './chat/ChatToolIdHelper'
import { ChatManualSearchFlow, ChatManualSearchFlowDependencies } from './chat/ChatManualSearchFlow'
import { ChatSendFlow, ChatSendFlowDependencies, ChatSendDispatchResult } from './chat/ChatSendFlow'
import { ChatStopFlow, ChatStopFlowDependencies } from './chat/ChatStopFlow'
import { ChatInlineEditFlow, ChatInlineEditFlowDependencies } from './chat/ChatInlineEditFlow'
import { ChatSelectionFlow, ChatSelectionFlowDependencies } from './chat/ChatSelectionFlow'
import { ChatPageLoadFlow, ChatPageLoadFlowDependencies, ChatPageLoadResult } from './chat/ChatPageLoadFlow'
import { ChatTaskAlertFlow, ChatTaskAlertFlowDependencies } from './chat/ChatTaskAlertFlow'
import { ChatScrollUiFlow, ChatScrollUiFlowDependencies } from './chat/ChatScrollUiFlow'
import {
  collectTailMessageIds,
  findMessageIndexById,
  resolveUserMessageIndexForRegenerate,
  toListScrollIndexForMessage
} from './chat/ChatMessageActionHelper'
import { ChatPageRouteParams } from './chat/ChatPageRouteTypes'

const DOMAIN = 0x0003
const TAG = 'ChatPage'

@Component
export struct ChatPage {
  navPathStack: NavPathStack = new NavPathStack()
  routeParams: ChatPageRouteParams | null = null
  // æ¶ˆæ¯æ•°æ®æºï¼ˆæ›¿ä»£ @State messagesï¼‰
  private messageDataSource: MessageDataSource = createMessageDataSource()
  // ä¿ç•™æ¶ˆæ¯æ•°ç»„å¼•ç”¨ç”¨äºå…¼å®¹æ€§ï¼ˆä¾‹å¦‚è®¡ç®—æ¶ˆæ¯æ•°é‡ï¼‰
  @State messages: ChatMessage[] = []
  @State @Watch('onDraftContentChanged') inputText: string = ''
  @State currentModel: string = ''
  @State currentModelId: string = ''
  @State isModelSelectorVisible: boolean = false
  @State modelSheetActivePanel: string = 'selector'
  @State editingModel: ModelInfo | null = null
  @State editingModelProvider: ModelProvider | null = null
  @State isLoading: boolean = false
  @State isSending: boolean = false
  // åº”ç”¨æ˜¯å¦é€€åˆ°åå°ï¼ˆç”¨äºå¤„ç†ç”Ÿæˆä¸­è¿”å›æ¡Œé¢/å…³é—­åº”ç”¨ï¼‰
  @StorageProp('appInBackground') @Watch('onAppInBackgroundChanged') appInBackground: boolean = false
  @StorageProp('task_unread_by_session') @Watch('onTaskUnreadBySessionChanged') taskUnreadBySessionJson: string = '{}'
  @StorageProp('in_app_task_alert_payload') @Watch('onInAppTaskAlertPayloadChanged') inAppTaskAlertPayload: string = ''
  @StorageProp('openSessionPayload') @Watch('onOpenSessionPayloadChanged') openSessionPayload: string = ''
  @State providers: ModelProvider[] = []
  // é™„ä»¶ç›¸å…³çŠ¶æ€
  @State pendingAttachments: MessageAttachment[] = []
  @State showAttachmentPicker: boolean = false
  // æ˜¯å¦åœ¨åˆ—è¡¨åº•éƒ¨
  @State isAtBottom: boolean = false
  // æ˜¯å¦åœ¨åˆ—è¡¨é¡¶éƒ¨
  @State isAtTop: boolean = false
  // è¾“å…¥æ¡†æ˜¾ç¤ºçŠ¶æ€ï¼ˆtrue=æ˜¾ç¤ºï¼Œfalse=éšè—ï¼‰
  @State isInputBarVisible: boolean = true
  // è¾“å…¥æ¡†æ˜¯å¦å¤„äºç„¦ç‚¹çŠ¶æ€ï¼ˆç”¨äºæ§åˆ¶é¢„è§ˆæ°”æ³¡æ˜¾ç¤ºï¼‰
  @State isInputFocused: boolean = false
  // è®¡ç®—æ»šåŠ¨åç§»
  private lastScrollOffset: number = 0
  private readonly inputBarShowThreshold: number = 6
  private readonly inputBarHideThreshold: number = 18
  // ä¼šè¯æ ‡é¢˜ç›¸å…³çŠ¶æ€
  @State sessionTitle: string = 'æ–°å¯¹è¯'
  @State isTitleGenerating: boolean = false
  @State titleGenerateFailed: boolean = false
  // æ›´å¤šèœå•æ˜¾ç¤ºçŠ¶æ€
  @State showMoreMenu: boolean = false
  // æ ‡é¢˜å†…è”ç¼–è¾‘çŠ¶æ€ï¼ˆå·²è¿ç§»åˆ° ChatNavigationBarï¼Œä¿ç•™ç”¨äºå›è°ƒï¼‰
  // å›¾ç‰‡é¢„è§ˆçŠ¶æ€
  @State showImagePreview: boolean = false
  @State previewImages: Array<string> = []
  @State previewImageIndex: number = 0
  // å½“å‰æ­£åœ¨æœ—è¯»çš„æ¶ˆæ¯ID
  @StorageLink('speakingMessageId') speakingMessageId: string = ''
  // æ˜¯å¦ä¸ºé€šè¿‡"æ–°å»ºå¯¹è¯"åˆ›å»ºçš„ç©ºä¼šè¯ï¼ˆè¿”å›æ—¶éœ€è¦åˆ é™¤ï¼‰
  private isNewEmptySession: boolean = false
  // æœç´¢å–æ¶ˆæ ‡å¿—ï¼ˆç”¨äºå–æ¶ˆæ­£åœ¨è¿›è¡Œçš„è”ç½‘æŸ¥è¯¢ï¼‰
  private isSearchCancelled: boolean = false
  // è”ç½‘æŸ¥è¯¢å…¨å±€å¯ç”¨çŠ¶æ€ï¼ˆå·¥å…·ä¸­å¿ƒæ§åˆ¶ï¼‰
  @State webSearchAvailable: boolean = false
  // è”ç½‘æŸ¥è¯¢æœ¬ä¼šè¯å¼€å…³çŠ¶æ€ï¼ˆèŠå¤©é¡µæ§åˆ¶ï¼‰
  @State webSearchEnabled: boolean = false
  // å¤©æ°”æŸ¥è¯¢çŠ¶æ€
  @State weatherQueryEnabled: boolean = false
  // æ¨ç†çº§åˆ«çŠ¶æ€
  @State reasoningLevel: ReasoningLevel = ReasoningLevel.OFF
  // æœ€è¿‘æˆªå›¾æ£€æµ‹çŠ¶æ€ï¼ˆç”± ChatInputBar å›è°ƒè®¾ç½®ï¼ŒScreenshotBanner ç‹¬ç«‹æ¸²æŸ“ï¼‰
  @State hasRecentScreenshot: boolean = false
  // æ˜¯å¦ä¸ºæ–°å»ºå¯¹è¯ï¼ˆç”¨äºåŠ è½½å’Œè‡ªåŠ¨å‘é€ç­–ç•¥ï¼‰
  @State isNewChatTransition: boolean = false
  // æ˜¯å¦è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
  @State autoFocusInput: boolean = false
  // é¿è®©åŒºåŸŸé«˜åº¦
  @StorageProp('topAvoidHeight') topAvoidHeight: number = 0
  @StorageProp('bottomAvoidHeight') bottomAvoidHeight: number = 0
  // ä¸»é¢˜é¢œè‰²
  @StorageProp('theme_primary') themePrimary: string = '#0A59F7'
  @StorageProp('theme_user_bubble') themeUserBubble: string = '#0A59F7'
  @StorageProp('theme_user_bubble_text') themeUserBubbleText: string = '#FFFFFF'
  // å¤šé€‰æ¨¡å¼çŠ¶æ€
  @State isMultiSelectMode: boolean = false
  @State selectedMessageIds: Array<string> = []
  // åˆ†äº«é¢„è§ˆå¼¹çª—çŠ¶æ€
  @State showSharePreview: boolean = false
  @State shareMessages: ChatMessage[] = []
  // ç¼–è¾‘æ¶ˆæ¯ç›¸å…³çŠ¶æ€ï¼ˆå†…è”ç¼–è¾‘æ¨¡å¼ï¼‰
  @State isEditingMessage: boolean = false // æ˜¯å¦å¤„äºæ¶ˆæ¯ç¼–è¾‘æ¨¡å¼
  @State editingMessageId: string = '' // æ­£åœ¨ç¼–è¾‘çš„æ¶ˆæ¯ID
  @State editingOriginalContent: string = '' // åŸå§‹å†…å®¹ï¼ˆç”¨äºå–æ¶ˆç¼–è¾‘ï¼‰
  @State editingOriginalAttachments: MessageAttachment[] = [] // åŸå§‹é™„ä»¶
  @State editingMessageIsUser: boolean = true // æ˜¯å¦ä¸ºç”¨æˆ·æ¶ˆæ¯ï¼ˆå†³å®šæ˜¯å¦æ˜¾ç¤º"ä¿å­˜å¹¶å‘é€"ï¼‰
  @State editingWebSearchEnabled: boolean = false
  @State editingReasoningLevel: ReasoningLevel = ReasoningLevel.OFF
  @State otherSessionUnreadCount: number = 0
  private scroller: Scroller = new Scroller()
  private chatViewModel: ChatViewModel = ServiceRegistry.chat()
  private providerViewModel: ProviderViewModel = ServiceRegistry.provider()
  private appStateManager: AppStateManager = ServiceRegistry.appState()
  private webSearchService: WebSearchService = ServiceRegistry.webSearch()
  private defaultModelService: DefaultModelService = ServiceRegistry.defaultModel()
  private preferencesService: PreferencesService = ServiceRegistry.preferences()
  private aiTaskService: AITaskService = ServiceRegistry.aiTask()
  private toolRegistry: ToolRegistry = ServiceRegistry.toolRegistry()
  private chatTaskOrchestrator = ServiceRegistry.chatTaskOrchestrator()
  private ttsService: TTSService = new TTSService()
  // å½“å‰æœåŠ¡å•†é…ç½®
  private currentProvider: ModelProvider | null = null
  private sessionId: string = ''
  private pendingInitialPrompt: string = ''
  private pendingInitialToolIds: string[] = []
  private initialPromptAutoSent: boolean = false
  private forcedToolIdsOnce: string[] = []
  private currentTaskId: string = ''
  private lastHandledAlertTimestamp: number = 0
  private streamSyncTimerId: number = -1
  private manualSearchFlow: ChatManualSearchFlow | null = null
  private sendFlow: ChatSendFlow | null = null
  private stopFlow: ChatStopFlow | null = null
  private inlineEditFlow: ChatInlineEditFlow | null = null
  private selectionFlow: ChatSelectionFlow | null = null
  private loadFlow: ChatPageLoadFlow | null = null
  private taskAlertFlow: ChatTaskAlertFlow | null = null
  private scrollUiFlow: ChatScrollUiFlow | null = null

  private showChatSnack(message: string | Resource, duration: number = 2000,
    tone: SnackBarTone = SnackBarTone.DEFAULT): void {
    const options: SnackBarDisplayOptions = new SnackBarDisplayOptions()
    options.message = message
    options.duration = duration
    options.tone = tone
    showSnackBar(this.getUIContext(), options)
  }

  aboutToAppear(): void {
    // è®¾ç½®é”®ç›˜é¿è®©æ¨¡å¼
    this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE)

    // æ³¨å†Œå†…ç½®å·¥å…·
    registerBuiltinTools()

    // è®¾ç½®æ ‡é¢˜ç”Ÿæˆå›è°ƒ
    const titleCallbacks: TitleGenerationCallbacks = {
      onTitleUpdated: (title: string): void => {
        this.sessionTitle = title
        this.titleGenerateFailed = false
      },
      onTitleGenerating: (isGenerating: boolean): void => {
        this.isTitleGenerating = isGenerating
      },
      onTitleFailed: (): void => {
        this.titleGenerateFailed = true
        this.showChatSnack($r('app.string.title_generate_failed_config'), 2000, SnackBarTone.ERROR)
      }
    }
    this.chatViewModel.setTitleCallbacks(titleCallbacks)

    // åˆå§‹åŒ–TTSæœåŠ¡
    this.initTTSService()

    // å¦‚æœé€šè¿‡ navDestination builder ä¼ å…¥äº† routeParamsï¼Œç›´æ¥åˆå§‹åŒ–
    // å¦åˆ™ç­‰ onReady å›è°ƒè®¾ç½® routeParams åå†åˆå§‹åŒ–
    if (this.routeParams !== null) {
      this.initWithParams(this.routeParams)
    }
  }

  // ä»è·¯ç”±å‚æ•°åˆå§‹åŒ–é¡µé¢ï¼ˆaboutToAppear æˆ– onReady è§¦å‘ï¼‰
  private initWithParams(params: ChatPageRouteParams | null): void {
    if (params !== null && params !== undefined) {
      console.info('ChatPage', `[initWithParams] sessionId=${params.sessionId ?? ''}`)
      if (params.sessionId !== undefined && params.sessionId !== '') {
        this.isNewChatTransition = false
      } else {
        this.isNewChatTransition = true
      }
    } else {
      console.info('ChatPage', '[initWithParams] params is null, treating as new chat')
      this.isNewChatTransition = true
    }
    this.loadData()
  }

  // ä¿®å¤é¡µé¢æ¢å¤æ—¶å¯èƒ½çš„ä¸ä¸€è‡´çŠ¶æ€
  private fixInconsistentState(): void {
    // å¦‚æœ isSending ä¸º true ä½†æ²¡æœ‰æ´»è·ƒè¯·æ±‚ï¼Œé‡ç½®çŠ¶æ€
    if (this.isSending && !this.chatViewModel.hasActiveRequest()) {
      this.isSending = false
      console.info('ChatPage', '[fixInconsistentState] é‡ç½® isSending çŠ¶æ€')
    }

    // æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯çš„ isGenerating å’Œ isSearching çŠ¶æ€
    if (this.messageDataSource.totalCount() > 0) {
      const lastMessage = this.messageDataSource.getData(this.messageDataSource.totalCount() - 1)
      if (lastMessage.role === MessageRole.ASSISTANT) {
        let needUpdate = false
        // å¦‚æœæ²¡æœ‰æ´»è·ƒè¯·æ±‚ï¼Œé‡ç½®ç”ŸæˆçŠ¶æ€
        if (lastMessage.isGenerating && !this.chatViewModel.hasActiveRequest()) {
          lastMessage.isGenerating = false
          needUpdate = true
          console.info('ChatPage', '[fixInconsistentState] é‡ç½®æœ€åä¸€æ¡æ¶ˆæ¯çš„ isGenerating çŠ¶æ€')
        }
        // å¦‚æœæ²¡æœ‰æ´»è·ƒè¯·æ±‚ï¼Œé‡ç½®æœç´¢çŠ¶æ€
        if (lastMessage.isSearching && !this.chatViewModel.hasActiveRequest()) {
          lastMessage.isSearching = false
          needUpdate = true
          console.info('ChatPage', '[fixInconsistentState] é‡ç½®æœ€åä¸€æ¡æ¶ˆæ¯çš„ isSearching çŠ¶æ€')
        }
        if (needUpdate) {
          this.messageDataSource.notifyLastMessageChanged()
        }
      }
    }
  }

  aboutToDisappear(): void {
    // é‡Šæ”¾TTSèµ„æº
    this.ttsService.destroy()
    this.clearStreamSyncTimer()
    AppStorage.setOrCreate(AppStorageKeys.ACTIVE_CHAT_SESSION_ID, '')

    // å¦‚æœæ˜¯é€šè¿‡"æ–°å»ºå¯¹è¯"åˆ›å»ºçš„ç©ºä¼šè¯ï¼Œè¿”å›æ—¶åˆ é™¤
    if (this.isNewEmptySession && this.messages.length === 0 && this.sessionId !== '') {
      this.chatViewModel.deleteSession(this.sessionId)
      console.info('ChatPage', 'åˆ é™¤ç©ºä¼šè¯: ' + this.sessionId)
    }
  }

  // åˆå§‹åŒ–TTSæœåŠ¡
  private async initTTSService(): Promise<void> {
    try {
      const context = this.getUIContext().getHostContext() as common.UIAbilityContext
      await this.ttsService.init(context)
    } catch (error) {
      console.error('ChatPage', 'TTSåˆå§‹åŒ–å¤±è´¥: ' + error)
    }
  }

  async loadData(): Promise<void> {
    const startTime = Date.now()
    hilog.info(DOMAIN, TAG, 'ğŸ“‚ å¼€å§‹åŠ è½½èŠå¤©é¡µé¢æ•°æ®...')

    // æ–°å»ºå¯¹è¯æ—¶ä¸æ˜¾ç¤ºåŠ è½½åŠ¨ç”»ï¼Œè®©ç”¨æˆ·æ— æ„Ÿ
    // åªæœ‰æ‰“å¼€ç°æœ‰å¯¹è¯æ—¶æ‰æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    if (!this.isNewChatTransition) {
      this.isLoading = true
    }

    const loadResult = await this.getLoadFlow().loadPageData(this.routeParams, this.sessionTitle)

    this.webSearchAvailable = loadResult.webSearchEnabled
    this.webSearchEnabled = this.webSearchAvailable && loadResult.webSearchConversationEnabled
    this.weatherQueryEnabled = loadResult.weatherQueryEnabled
    console.info(
      'ChatPage',
      `[loadData] è”ç½‘å¯ç”¨=${this.webSearchAvailable}, è”ç½‘ä¼šè¯å¼€å…³=${this.webSearchEnabled}, å¤©æ°”æŸ¥è¯¢=${this.weatherQueryEnabled}`
    )

    this.applyLoadedProviders(loadResult.providers)
    this.applyLoadedSessionData(loadResult)

    this.isLoading = false

    const elapsed = Date.now() - startTime
    hilog.info(DOMAIN, TAG, 'âœ… èŠå¤©é¡µé¢æ•°æ®åŠ è½½å®Œæˆ (è€—æ—¶: %{public}dms)', elapsed)

    this.triggerPostLoadActions()
    this.activateCurrentSessionRuntimeState()
  }

  private applyLoadedProviders(providers: ModelProvider[]): void {
    this.providers = providers
    console.info('ChatPage', `[loadData] Loaded ${this.providers.length} providers`)

    if (this.providers.length === 0) {
      this.currentModel = ''
      this.currentModelId = ''
      this.currentProvider = null
      return
    }
    this.validateAndSetCurrentModel()
  }

  private applyLoadedSessionData(loadResult: ChatPageLoadResult): void {
    this.pendingInitialPrompt = loadResult.pendingInitialPrompt
    this.pendingInitialToolIds = loadResult.pendingInitialToolIds
    this.initialPromptAutoSent = loadResult.initialPromptAutoSent
    this.sessionId = loadResult.sessionId
    this.sessionTitle = loadResult.sessionTitle
    this.isNewChatTransition = loadResult.isNewChatTransition
    this.isNewEmptySession = loadResult.isNewEmptySession

    if (!this.isNewChatTransition) {
      this.messageDataSource.setAllMessages(loadResult.messages)
      this.messages = [...loadResult.messages]
      hilog.info(DOMAIN, TAG, 'ğŸ“¨ åŠ è½½ä¼šè¯æ¶ˆæ¯: %{public}d æ¡', this.messages.length)
      return
    }

    this.messageDataSource.clear()
    this.messages = []
  }

  private triggerPostLoadActions(): void {
    if (this.isNewChatTransition) {
      setTimeout(() => {
        this.autoFocusInput = true
      }, 50)
    }

    if (this.isNewChatTransition && this.pendingInitialPrompt !== '' && !this.initialPromptAutoSent) {
      setTimeout(() => {
        this.autoSendInitialPrompt()
      }, 120)
    }
  }

  onTaskUnreadBySessionChanged(): void {
    this.getTaskAlertFlow().refreshOtherSessionUnreadCount()
  }

  onInAppTaskAlertPayloadChanged(): void {
    this.getTaskAlertFlow().handleInAppTaskAlertPayload(this.inAppTaskAlertPayload)
  }

  onOpenSessionPayloadChanged(): void {
    this.getTaskAlertFlow().handleOpenSessionPayload(this.openSessionPayload)
  }

  private handlePageShown(): void {
    if (this.isLoading || this.sessionId === '') {
      return
    }
    this.refreshToolAvailabilityOnShown()
    this.syncSendingStateFromRuntime()
    this.fixInconsistentState()
    this.refreshProviders()
    AppStorage.setOrCreate(AppStorageKeys.ACTIVE_CHAT_SESSION_ID, this.sessionId)
    this.chatTaskOrchestrator.markSessionRead(this.sessionId)
    this.getTaskAlertFlow().refreshOtherSessionUnreadCount()
    this.updateStreamSyncTimer()
  }

  private activateCurrentSessionRuntimeState(): void {
    AppStorage.setOrCreate(AppStorageKeys.ACTIVE_CHAT_SESSION_ID, this.sessionId)
    this.chatTaskOrchestrator.markSessionRead(this.sessionId)
    this.getTaskAlertFlow().refreshOtherSessionUnreadCount()
    this.syncSendingStateFromRuntime()
    this.getTaskAlertFlow().handleOpenSessionPayload(this.openSessionPayload)
    this.getTaskAlertFlow().handleInAppTaskAlertPayload(this.inAppTaskAlertPayload)
    this.updateStreamSyncTimer()
  }

  private refreshToolAvailabilityOnShown(): void {
    this.refreshToolAvailabilityFromPreferences(true).catch((error: Object) => {
      console.warn('ChatPage', `[refreshToolAvailabilityOnShown] Failed: ${JSON.stringify(error)}`)
    })
  }

  private async refreshToolAvailabilityFromPreferences(syncConversationSwitch: boolean): Promise<void> {
    const webSearchAvailable = await this.preferencesService.getBoolean(PreferenceKeys.SEARCH_SERVICE_ENABLED, false)
    const weatherQueryEnabled = await this.preferencesService.getBoolean(
      PreferenceKeys.WEATHER_QUERY_ENABLED,
      webSearchAvailable
    )
    let webSearchConversationEnabled = this.webSearchEnabled
    if (syncConversationSwitch) {
      webSearchConversationEnabled = await this.preferencesService.getBoolean(
        PreferenceKeys.SEARCH_CONVERSATION_ENABLED,
        webSearchAvailable
      )
    }
    this.webSearchAvailable = webSearchAvailable
    if (!this.webSearchAvailable) {
      this.webSearchEnabled = false
    } else {
      this.webSearchEnabled = webSearchConversationEnabled
    }
    this.weatherQueryEnabled = weatherQueryEnabled
  }

  private syncSendingStateFromRuntime(): void {
    if (this.sessionId === '') {
      this.isSending = false
      return
    }
    this.isSending = this.chatViewModel.hasActiveRequestForSession(this.sessionId)
  }

  private hasStreamingAssistantMessage(): boolean {
    const total = this.messageDataSource.totalCount()
    if (total <= 0) {
      return false
    }
    const lastMessage = this.messageDataSource.getData(total - 1)
    if (lastMessage.role !== MessageRole.ASSISTANT) {
      return false
    }
    return lastMessage.isGenerating || lastMessage.isSearching
  }

  private notifyStreamingMessageChanged(forceNotify: boolean): void {
    const total = this.messageDataSource.totalCount()
    if (total <= 0) {
      return
    }
    const lastMessage = this.messageDataSource.getData(total - 1)
    if (lastMessage.role !== MessageRole.ASSISTANT) {
      return
    }
    if (forceNotify || lastMessage.isGenerating || lastMessage.isSearching) {
      this.messageDataSource.notifyLastMessageChanged()
      this.syncMessagesFromDataSource()
    }
  }

  private updateStreamSyncTimer(): void {
    if (!this.chatViewModel.hasActiveRequest() || !this.hasStreamingAssistantMessage()) {
      this.clearStreamSyncTimer()
      return
    }
    if (this.streamSyncTimerId !== -1) {
      return
    }
    this.streamSyncTimerId = setInterval(() => {
      if (!this.chatViewModel.hasActiveRequest()) {
        this.notifyStreamingMessageChanged(true)
        this.clearStreamSyncTimer()
        return
      }
      this.notifyStreamingMessageChanged(false)
    }, 180)
  }

  private clearStreamSyncTimer(): void {
    if (this.streamSyncTimerId !== -1) {
      clearInterval(this.streamSyncTimerId)
      this.streamSyncTimerId = -1
    }
  }

  private parseToolIdsFromRoute(raw: string): string[] {
    return parseToolIdsFromRouteRaw(raw)
  }

  private getSendFlow(): ChatSendFlow {
    if (this.sendFlow !== null) {
      return this.sendFlow
    }
    const deps = new ChatSendFlowDependencies(
      this.chatViewModel,
      this.messageDataSource,
      this.chatTaskOrchestrator,
      this.toolRegistry,
      (): string => this.sessionId,
      (): string => this.sessionTitle,
      (): string => this.currentTaskId,
      (): string => this.currentModelId,
      (): string => this.currentModel,
      (): ChatMessage[] => this.messages,
      (): ReasoningLevel => this.reasoningLevel,
      (): void => {
        this.inputText = ''
        this.pendingAttachments = []
      },
      (): void => {
        this.safeStopInputSession()
        this.scroller.scrollEdge(Edge.Bottom)
      },
      (value: boolean): void => {
        this.isSending = value
      },
      (taskId: string): void => {
        this.currentTaskId = taskId
      },
      (): void => {
        this.syncMessagesFromDataSource()
      },
      (): void => {
        this.scroller.scrollEdge(Edge.Bottom)
      },
      (value: boolean): void => {
        this.isNewEmptySession = value
      },
      (): void => {
        // no-op
      },
      (message: string): void => {
        // no-op
      },
      (message: string | Resource): void => {
        this.showError(message)
      },
      (message: string | Resource): void => {
        this.showChatSnack(message)
      }
    )
    this.sendFlow = new ChatSendFlow(deps)
    return this.sendFlow
  }

  private getStopFlow(): ChatStopFlow {
    if (this.stopFlow !== null) {
      return this.stopFlow
    }
    const deps = new ChatStopFlowDependencies(
      this.chatViewModel,
      this.chatTaskOrchestrator,
      this.messageDataSource,
      (): string => this.currentTaskId,
      (taskId: string): void => {
        this.currentTaskId = taskId
      },
      (value: boolean): void => {
        this.isSearchCancelled = value
      },
      (): void => {
        if (this.manualSearchFlow !== null) {
          this.manualSearchFlow.cancelCurrentSearchRequest()
          return
        }
        this.webSearchService.cancelAllRequests()
      },
      (): void => {
        this.syncMessagesFromDataSource()
      },
      (value: boolean): void => {
        this.isSending = value
      },
      (value: boolean): void => {
        this.isLoading = value
      },
      (): void => {
        this.forcedToolIdsOnce = []
      },
      (message: string): void => {
        // no-op
      }
    )
    this.stopFlow = new ChatStopFlow(deps)
    return this.stopFlow
  }

  private getManualSearchFlow(): ChatManualSearchFlow {
    if (this.manualSearchFlow !== null) {
      return this.manualSearchFlow
    }
    const deps = new ChatManualSearchFlowDependencies(
      this.chatViewModel,
      this.providerViewModel,
      this.webSearchService,
      this.defaultModelService,
      this.preferencesService,
      this.appStateManager,
      this.messageDataSource,
      (): ModelProvider | null => this.currentProvider,
      (): string => this.currentModelId,
      (): string => this.currentModel,
      (): ChatMessage[] => this.messages,
      (): ReasoningLevel => this.reasoningLevel,
      (): boolean => this.isSearchCancelled,
      (): void => this.syncMessagesFromDataSource(),
      (): void => this.scroller.scrollEdge(Edge.Bottom),
      (value: boolean): void => {
        this.isSending = value
      },
      (value: boolean): void => {
        this.isSearchCancelled = value
      },
      (): void => {
        this.inputText = ''
        this.pendingAttachments = []
      },
      (): void => {
        this.safeStopInputSession()
        this.scroller.scrollEdge(Edge.Bottom)
      },
      (value: boolean): void => {
        this.isNewEmptySession = value
      },
      (message: string): void => {
        // no-op
      },
      (): void => {
        // no-op
      },
      (message: string | Resource): void => {
        this.showError(message)
      },
      (message: string | Resource): void => {
        this.showChatSnack(message)
      }
    )
    this.manualSearchFlow = new ChatManualSearchFlow(deps)
    return this.manualSearchFlow
  }

  private getInlineEditFlow(): ChatInlineEditFlow {
    if (this.inlineEditFlow !== null) {
      return this.inlineEditFlow
    }
    const deps = new ChatInlineEditFlowDependencies(
      this.chatViewModel,
      this.messageDataSource,
      (): ChatMessage[] => this.messages,
      (): void => {
        this.syncMessagesFromDataSource()
      },
      (): void => {
        this.isEditingMessage = false
        this.editingMessageId = ''
        this.editingOriginalContent = ''
        this.editingOriginalAttachments = []
        this.editingWebSearchEnabled = false
        this.editingReasoningLevel = ReasoningLevel.OFF
      },
      (
        content: string,
        attachments: MessageAttachment[],
        webSearchEnabled: boolean,
        reasoningLevel: ReasoningLevel
      ): void => {
        this.inputText = content
        this.pendingAttachments = attachments
        this.webSearchEnabled = webSearchEnabled
        this.reasoningLevel = reasoningLevel
      },
      (value: boolean): void => {
        this.isSending = value
      },
      (): void => {
        this.handleSend()
      },
      (message: string | Resource): void => {
        this.showChatSnack(message)
      }
    )
    this.inlineEditFlow = new ChatInlineEditFlow(deps)
    return this.inlineEditFlow
  }

  private getSelectionFlow(): ChatSelectionFlow {
    if (this.selectionFlow !== null) {
      return this.selectionFlow
    }
    const deps = new ChatSelectionFlowDependencies(
      this.chatViewModel,
      this.messageDataSource,
      (): ChatMessage[] => this.messages,
      (messages: ChatMessage[]): void => {
        this.messages = messages
      },
      (): void => {
        this.syncMessagesFromDataSource()
      },
      (value: boolean): void => {
        this.isMultiSelectMode = value
      },
      (ids: string[]): void => {
        this.selectedMessageIds = ids
      },
      (value: boolean): void => {
        this.getScrollUiFlow().setInputBarVisible(value)
      },
      (messages: ChatMessage[]): void => {
        this.shareMessages = messages
      },
      (value: boolean): void => {
        this.showSharePreview = value
      },
      (message: string | Resource): void => {
        this.showChatSnack(message)
      }
    )
    this.selectionFlow = new ChatSelectionFlow(deps)
    return this.selectionFlow
  }

  private getLoadFlow(): ChatPageLoadFlow {
    if (this.loadFlow !== null) {
      return this.loadFlow
    }
    const deps = new ChatPageLoadFlowDependencies(
      this.appStateManager,
      this.preferencesService,
      this.providerViewModel,
      this.chatViewModel,
      (raw: string): string[] => {
        return this.parseToolIdsFromRoute(raw)
      }
    )
    this.loadFlow = new ChatPageLoadFlow(deps)
    return this.loadFlow
  }

  private getTaskAlertFlow(): ChatTaskAlertFlow {
    if (this.taskAlertFlow !== null) {
      return this.taskAlertFlow
    }
    const deps = new ChatTaskAlertFlowDependencies(
      this.chatTaskOrchestrator,
      (): string => this.taskUnreadBySessionJson,
      (): string => this.sessionId,
      (): number => this.lastHandledAlertTimestamp,
      (count: number): void => {
        this.otherSessionUnreadCount = count
      },
      (value: number): void => {
        this.lastHandledAlertTimestamp = value
      },
      (sessionId: string): void => {
        this.navPathStack.replacePath({ name: 'ChatPage', param: { sessionId: sessionId } as ChatPageRouteParams })
      },
      (): void => {
        AppStorage.setOrCreate(AppStorageKeys.OPEN_SESSION_PAYLOAD, '')
      },
      (): void => {
        AppStorage.setOrCreate(AppStorageKeys.IN_APP_TASK_ALERT_PAYLOAD, '')
      },
      (): UIContext => {
        return this.getUIContext()
      }
    )
    this.taskAlertFlow = new ChatTaskAlertFlow(deps)
    return this.taskAlertFlow
  }

  private getScrollUiFlow(): ChatScrollUiFlow {
    if (this.scrollUiFlow !== null) {
      return this.scrollUiFlow
    }
    const deps = new ChatScrollUiFlowDependencies(
      this.scroller,
      this.messageDataSource,
      (): number => this.lastScrollOffset,
      (value: number): void => {
        this.lastScrollOffset = value
      },
      (): number => this.inputBarShowThreshold,
      (): number => this.inputBarHideThreshold,
      (): boolean => this.isAtTop,
      (): boolean => this.isAtBottom,
      (): boolean => this.isInputBarVisible,
      (): boolean => this.isSending,
      (): boolean => this.isInputFocused,
      (): boolean => this.isEditingMessage,
      (): string => this.editingMessageId,
      (): boolean => this.inputText.trim() !== '' || this.pendingAttachments.length > 0,
      (value: boolean): void => {
        this.isAtTop = value
      },
      (value: boolean): void => {
        this.isAtBottom = value
      },
      (value: boolean): void => {
        this.isInputBarVisible = value
      },
      (duration: number, curve: Curve, updater: () => void): void => {
        this.getUIContext().animateTo({
          duration: duration,
          curve: curve
        }, updater)
      }
    )
    this.scrollUiFlow = new ChatScrollUiFlow(deps)
    return this.scrollUiFlow
  }

  private async autoSendInitialPrompt(): Promise<void> {
    if (this.initialPromptAutoSent || this.pendingInitialPrompt === '') {
      return
    }
    if (this.isSending) {
      return
    }

    this.initialPromptAutoSent = true
    this.inputText = this.pendingInitialPrompt
    this.pendingInitialPrompt = ''
    this.forcedToolIdsOnce = [...this.pendingInitialToolIds]
    if (this.pendingInitialToolIds.includes('web_search') && this.webSearchAvailable) {
      this.webSearchEnabled = true
    }

    await this.sendMessage()
  }

  // éªŒè¯å½“å‰æ¨¡å‹æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœæ— æ•ˆåˆ™è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å‹
  private validateAndSetCurrentModel(): void {
    const savedModelId = this.appStateManager.getCurrentModelId()
    const savedProviderId = this.appStateManager.getCurrentProviderId()

    // æ£€æŸ¥ä¿å­˜çš„ä¾›åº”å•†å’Œæ¨¡å‹æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
    let isValid = false
    for (let i = 0; i < this.providers.length; i++) {
      const provider = this.providers[i]
      if (provider.id === savedProviderId) {
        // ä¾›åº”å•†å­˜åœ¨ï¼Œæ£€æŸ¥æ¨¡å‹æ˜¯å¦å¯ç”¨
        for (let j = 0; j < provider.models.length; j++) {
          const model = provider.models[j]
          if (model.id === savedModelId && model.isEnabled) {
            // æ¨¡å‹æœ‰æ•ˆ
            isValid = true
            this.currentProvider = provider
            this.currentModelId = savedModelId
            this.currentModel = this.appStateManager.getCurrentModelName()
            break
          }
        }
        break
      }
    }

    // å¦‚æœä¿å­˜çš„æ¨¡å‹æ— æ•ˆï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å‹
    if (!isValid) {
      this.selectFirstAvailableModel()
    }
  }

  // é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„æ¨¡å‹ï¼ˆä¼˜å…ˆä½¿ç”¨é»˜è®¤èŠå¤©æ¨¡å‹ï¼‰
  private async selectFirstAvailableModel(): Promise<void> {
    // å…ˆå°è¯•ä½¿ç”¨é»˜è®¤èŠå¤©æ¨¡å‹é…ç½®
    await this.defaultModelService.initialize()
    const defaultChatModel = this.defaultModelService.getModel(ModelRole.CHAT)

    if (defaultChatModel.isConfigured()) {
      // æ£€æŸ¥é»˜è®¤æ¨¡å‹æ˜¯å¦ä»ç„¶å¯ç”¨
      for (let i = 0; i < this.providers.length; i++) {
        const provider = this.providers[i]
        if (provider.id === defaultChatModel.providerId) {
          for (let j = 0; j < provider.models.length; j++) {
            const model = provider.models[j]
            if (model.id === defaultChatModel.modelId && model.isEnabled) {
              // é»˜è®¤æ¨¡å‹å¯ç”¨ï¼Œä½¿ç”¨å®ƒ
              this.currentProvider = provider
              this.currentModelId = model.id
              this.currentModel = model.name
              await this.appStateManager.setCurrentModel(model.id, model.name, provider.id)
              console.info('ChatPage', `Using default chat model: ${model.name} from ${provider.name}`)
              return
            }
          }
          break
        }
      }
      console.warn('ChatPage',
        `Default chat model configured but not available: ${defaultChatModel.modelName} from ${defaultChatModel.providerName}`)
    }

    // é»˜è®¤æ¨¡å‹æœªé…ç½®æˆ–ä¸å¯ç”¨ï¼Œå›é€€åˆ°ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å‹
    for (let i = 0; i < this.providers.length; i++) {
      const provider = this.providers[i]
      for (let j = 0; j < provider.models.length; j++) {
        const model = provider.models[j]
        if (model.isEnabled) {
          this.currentProvider = provider
          this.currentModelId = model.id
          this.currentModel = model.name
          await this.appStateManager.setCurrentModel(model.id, model.name, provider.id)
          console.info('ChatPage', `Auto-selected fallback model: ${model.name} from ${provider.name}`)
          return
        }
      }
    }

    // æ²¡æœ‰å¯ç”¨æ¨¡å‹
    this.currentProvider = null
    this.currentModelId = ''
    this.currentModel = ''
  }

  private async refreshProviders(): Promise<void> {
    await this.appStateManager.loadState()

    const providers = await this.providerViewModel.loadProviders()
    console.info('ChatPage', `[refreshProviders] Loaded ${providers.length} providers`)

    if (providers.length > 0) {
      this.providers = providers
    }

    if (this.providers.length === 0) {
      this.currentModel = ''
      this.currentModelId = ''
      this.currentProvider = null
    } else {
      // éªŒè¯å¹¶è®¾ç½®å½“å‰æ¨¡å‹
      this.validateAndSetCurrentModel()
    }
  }

  build() {
    NavDestination() {
      Stack() {
        // æ¶ˆæ¯åˆ—è¡¨ - å æ»¡å…¨å±
        ChatMessageListSection({
          isLoading: this.isLoading,
          loadingColor: this.themePrimary,
          scroller: this.scroller,
          messageDataSource: this.messageDataSource,
          topAvoidHeight: this.px2vp(this.topAvoidHeight),
          isEditingMessage: this.isEditingMessage,
          editingMessageId: this.editingMessageId,
          selectedMessageIds: this.selectedMessageIds,
          isMultiSelectMode: this.isMultiSelectMode,
          inputText: this.inputText,
          pendingAttachments: this.pendingAttachments,
          showDraftPreview: this.hasDraftContent(),
          draftPreviewTimeText: this.getPreviewTimeText(),
          bottomPadding: this.getListBottomPadding(),
          currentModelId: this.currentModelId,
          onRegenerate: (message: ChatMessage): void => {
            this.handleRegenerate(message)
          },
          onDelete: (message: ChatMessage): void => {
            this.handleDeleteMessage(message)
          },
          onEdit: (message: ChatMessage): void => {
            this.handleEditMessage(message)
          },
          onCancelEdit: (): void => {
            this.handleCancelEdit()
          },
          onShareMessage: (message: ChatMessage): void => {
            this.handleShareSingleMessage(message)
          },
          onTranslate: (content: string, targetLang: string,
            callback: (result: string, errorMessage: string) => void): void => {
            this.handleTranslate(content, targetLang, callback)
          },
          onImageClick: (images: Array<string>, imageIndex: number): void => {
            this.handleImagePreview(images, imageIndex)
          },
          onTTS: (messageId: string, content: string): void => {
            this.handleTTS(messageId, content)
          },
          onTTSStop: (): void => {
            this.handleTTSStop()
          },
          onSelect: (messageId: string): void => {
            this.handleToggleMessageSelection(messageId)
          },
          onEnterMultiSelect: (messageId: string): void => {
            this.handleEnterMultiSelectMode(messageId)
          },
          onListAppear: (): void => {
            hilog.info(DOMAIN, TAG, 'ğŸ‘ï¸ æ¶ˆæ¯åˆ—è¡¨å·²æ˜¾ç¤º (æ¶ˆæ¯æ•°: %{public}d)', this.messages.length)
          },
          onReachStart: (): void => {
            this.getScrollUiFlow().setIsAtTop(true)
          },
          onReachEnd: (): void => {
            this.getScrollUiFlow().setIsAtBottom(true)
            this.getScrollUiFlow().setInputBarVisible(true)
          },
          onDidScroll: (scrollOffset: number, scrollState: ScrollState): void => {
            this.handleMessageListDidScroll(scrollOffset, scrollState)
          }
        })
        .width('100%')
        .height('100%')
        .backgroundColor($r('app.color.background'))

        // ç¼–è¾‘æ¨¡å¼ç‚¹å‡»å±‚ - ç‚¹å‡»ç©ºç™½å¤„å–æ¶ˆç¼–è¾‘
        if (this.isEditingMessage) {
          Column()
            .width('100%')
            .height('100%')
            .backgroundColor(Color.Transparent)
            .onClick(() => {
              this.handleCancelEdit()
            })
        }

        // é¡¶éƒ¨å¯¼èˆªæ  - ä½¿ç”¨ç‹¬ç«‹ç»„ä»¶
        ChatNavigationBar({
          sessionTitle: this.sessionTitle,
          currentModelId: this.currentModelId,
          currentProviderId: this.currentProvider?.id ?? '',
          currentModelName: this.currentModel,
          currentProviderName: this.currentProvider?.name ?? '',
          currentProviderIconType: this.currentProvider?.iconType ?? 'svg',
          currentProviderIconPath: this.currentProvider?.iconPath ?? '',
          currentProviderTextIcon: this.currentProvider?.textIcon ?? '',
          currentProviderTextIconBgColor: this.currentProvider?.textIconBgColor ?? '',
          currentProviderCustomImagePath: this.currentProvider?.customImagePath ?? '',
          currentProviderBrandColor: this.currentProvider?.brandColor ?? '',
          hasMessages: this.messages.length > 0,
          isTitleGenerating: this.isTitleGenerating,
          titleGenerateFailed: this.titleGenerateFailed,
          topAvoidHeight: this.px2vp(this.topAvoidHeight),
          isSending: this.isSending,
          otherSessionUnreadCount: this.otherSessionUnreadCount,
          onBack: () => {
            this.handleBack()
          },
          onModelSelect: () => {
            this.isModelSelectorVisible = true
            this.modelSheetActivePanel = 'selector'
          },
          onNewChat: () => {
            this.handleNewChat()
          },
          onRegenerateTitle: () => {
            this.handleRegenerateTitle()
          },
          onTitleChanged: (newTitle: string) => {
            this.handleSaveTitle(newTitle)
          },
          onNavigateToModelManage: () => {
            this.safePushUrl('pages/ModelManagePage')
          },
          onDeleteChat: () => {
            this.handleDeleteChat()
          }
        })
          .position({ x: 0, y: 0 })
          .bindSheet($$this.isModelSelectorVisible, this.ModelSelectorSheetBuilder(), {
            height: this.modelSheetActivePanel === 'selector' ? SheetSize.MEDIUM : SheetSize.LARGE,
            dragBar: true,
            showClose: this.modelSheetActivePanel === 'selector',
            title: { title: this.modelSheetActivePanel === 'selector' ? $r('app.string.select_model') : '' },
            blurStyle: BlurStyle.Thick,
            preferType: SheetType.BOTTOM,
            onDisappear: () => {
              this.isModelSelectorVisible = false
              this.modelSheetActivePanel = 'selector'
              this.editingModel = null
              this.editingModelProvider = null
            }
          })

        // å¿«é€Ÿåˆ°é¡¶éƒ¨æŒ‰é’®
        ScrollToBottomButton({
          isVisible: this.shouldShowScrollToTopButton(),
          isInputBarVisible: this.isInputBarVisible,
          bottomAvoidHeight: this.px2vp(this.bottomAvoidHeight),
          buttonDirection: 1,
          extraOffsetY: -48,
          onScrollToTop: () => {
            this.scrollToTopWithAnimation()
          }
        })

        // å›åˆ°åº•éƒ¨æŒ‰é’®
        ScrollToBottomButton({
          isVisible: !this.isAtBottom && !this.isMultiSelectMode,
          isInputBarVisible: this.isInputBarVisible,
          bottomAvoidHeight: this.px2vp(this.bottomAvoidHeight),
          buttonDirection: 0,
          onScrollToBottom: () => {
            this.scrollToBottomWithAnimation()
          }
        })

        // åº•éƒ¨è¾“å…¥æ å®¹å™¨ï¼ˆéå¤šé€‰æ¨¡å¼æ—¶æ˜¾ç¤ºï¼‰
        if (!this.isMultiSelectMode) {
          ChatInputAreaSection({
            inputText: $inputText,
            attachments: $pendingAttachments,
            isSending: this.isSending,
            isAwaitingResponse: this.calcIsAwaitingAiOutput(),
            currentModelId: this.currentModelId,
            currentProviderId: this.currentProvider?.id ?? '',
            currentModelName: this.currentModel,
            currentProviderIconType: this.currentProvider?.iconType ?? 'svg',
            currentProviderIconPath: this.currentProvider?.iconPath ?? '',
            currentProviderTextIcon: this.currentProvider?.textIcon ?? '',
            currentProviderTextIconBgColor: this.currentProvider?.textIconBgColor ?? '',
            currentProviderCustomImagePath: this.currentProvider?.customImagePath ?? '',
            currentProviderBrandColor: this.currentProvider?.brandColor ?? '',
            autoFocus: this.autoFocusInput,
            isEditing: this.isEditingMessage,
            webSearchAvailable: this.webSearchAvailable,
            webSearchEnabled: $webSearchEnabled,
            reasoningLevel: $reasoningLevel,
            hasRecentScreenshot: this.hasRecentScreenshot,
            bottomAvoidHeight: this.px2vp(this.bottomAvoidHeight),
            onCancelEdit: (): void => {
              this.handleCancelEdit()
            },
            onSend: (): void => {
              if (this.isEditingMessage) {
                this.handleSaveAndSendInline()
              } else {
                this.handleSend()
              }
            },
            onStop: (): void => {
              this.handleStop()
            },
            onModelIconClick: (): void => {
              this.isModelSelectorVisible = true
              this.modelSheetActivePanel = 'selector'
            },
            onAttachmentClick: (): void => {
              this.showAttachmentPicker = true
            },
            onInputFocus: (): void => {
              if (!this.isEditingMessage) {
                this.isInputFocused = true
                setTimeout(() => {
                  this.scroller.scrollEdge(Edge.Bottom)
                }, 200)
              }
            },
            onInputBlur: (): void => {
              if (!this.hasDraftContent()) {
                this.isInputFocused = false
              }
            },
            onRecentPhotoDetected: (detected: boolean): void => {
              this.hasRecentScreenshot = detected
            }
          })
          .position({ x: 0, y: '100%' })
          .translate({
            y: this.isInputBarVisible ? '-100%' : '0%',
            x: 0
          })
          .opacity(this.isInputBarVisible ? 1 : 0)
          .animation({
            duration: 220,
            curve: Curve.EaseOut
          })
          .bindSheet($$this.showAttachmentPicker, this.AttachmentPickerBuilder(), {
            height: 160,
            dragBar: false,
            showClose: false,
            backgroundColor: $r('app.color.surface'),
            blurStyle: BlurStyle.Thick,
            preferType: SheetType.BOTTOM
          })
        }

        // åˆ†äº«é¢„è§ˆ Sheet å®¿ä¸»ï¼ˆbindContentCover å’Œ bindSheet ä¸èƒ½åœ¨åŒä¸€ç»„ä»¶ä¸Šï¼Œå¦åˆ™ä¼šå†²çªï¼‰
        Column()
          .width(0)
          .height(0)
          .bindSheet($$this.showSharePreview, this.SharePreviewBuilder(), {
            height: SheetSize.LARGE,
            dragBar: true,
            showClose: false,
            backgroundColor: $r('app.color.background'),
            blurStyle: BlurStyle.Thick,
            preferType: SheetType.BOTTOM,
            onDisappear: () => {
              this.showSharePreview = false
            }
          })

        // å¤šé€‰å·¥å…·æ ï¼ˆå¤šé€‰æ¨¡å¼æ—¶æ˜¾ç¤ºï¼‰
        if (this.isMultiSelectMode) {
          Column() {
            MultiSelectToolbar({
              selectedCount: this.selectedMessageIds.length,
              totalCount: this.messages.length,
              onSelectAll: () => {
                this.handleSelectAllMessages()
              },
              onDelete: () => {
                this.handleDeleteSelectedMessages()
              },
              onShare: () => {
                this.handleShareSelectedMessages()
              },
              onCancel: () => {
                this.handleExitMultiSelectMode()
              }
            })

            // åº•éƒ¨å®‰å…¨åŒºåŸŸå ä½
            Column()
              .width('100%')
              .height(this.px2vp(this.bottomAvoidHeight))
          }
          .width('100%')
          .position({ x: 0, y: '100%' })
          .translate({ y: '-100%', x: 0 })
          .transition(TransitionEffect.OPACITY.animation({ duration: 200 }))
        }

        // å›¾ç‰‡é¢„è§ˆï¼ˆå…¨å±è¦†ç›–å±‚ï¼Œä¸ä½¿ç”¨ bindContentCover ä»¥é¿å…æ¨¡æ€å±‚æ‹¦æˆªæ‰‹åŠ¿ï¼‰
        if (this.showImagePreview) {
          ImagePreview({
            images: this.previewImages,
            currentIndex: this.previewImageIndex,
            onClose: () => {
              this.showImagePreview = false
            }
          })
            .transition(TransitionEffect.OPACITY.animation({ duration: 200 }))
        }
      }
      .width('100%')
      .height('100%')
      .clip(true)
    }
    .hideTitleBar(true)
    .hideBackButton(true)
    .backgroundColor(Color.Transparent)
    .onReady((context: NavDestinationContext) => {
      this.navPathStack = context.pathStack
      const param = context.pathInfo.param as ChatPageRouteParams
      if (param !== null && param !== undefined) {
        this.routeParams = param
      }
      // å¦‚æœ aboutToAppear æ—¶ routeParams è¿˜æ²¡è®¾ç½®ï¼Œè¿™é‡Œè§¦å‘åˆå§‹åŒ–
      if (this.sessionId === '') {
        this.initWithParams(this.routeParams)
      }
    })
    .onShown(() => {
      this.handlePageShown()
    })
    .onBackPressed((): boolean => {
      if (this.showImagePreview) {
        this.showImagePreview = false
        return true
      }
      this.handleBack()
      return true
    })
  }

  pageTransition() {
    PageTransitionEnter({
      type: RouteType.Push,
      duration: 350,
      curve: Curve.EaseOut
    })
      .slide(SlideEffect.Right)

    PageTransitionExit({
      type: RouteType.Pop,
      duration: 300,
      curve: Curve.EaseIn
    })
      .slide(SlideEffect.Right)

    // è¢«æ–°é¡µé¢è¦†ç›–æ—¶çš„é€€å‡ºåŠ¨ç”»
    PageTransitionExit({
      type: RouteType.Push,
      duration: 350,
      curve: Curve.EaseOut
    })
      .opacity(0.8)
      .translate({ x: '-20%' })

    // è¿”å›æ—¶çš„è¿›å…¥åŠ¨ç”»
    PageTransitionEnter({
      type: RouteType.Pop,
      duration: 300,
      curve: Curve.EaseOut
    })
      .opacity(1)
      .translate({ x: 0 })
  }

  // å¤„ç†å›¾ç‰‡é¢„è§ˆ
  private handleImagePreview(images: Array<string>, index: number): void {
    hilog.info(DOMAIN, TAG, 'ğŸ–¼ï¸ ChatPage.handleImagePreview (images: %{public}d, index: %{public}d)', images.length,
      index)
    this.previewImages = images
    this.previewImageIndex = index
    this.showImagePreview = true
  }

  @Builder
  ModelSelectorSheetBuilder() {
    ChatModelSelectorSheetContent({
      providers: this.providers,
      currentModelId: this.currentModelId,
      activePanel: this.modelSheetActivePanel,
      editingModel: $editingModel,
      onSelectModel: (providerId: string, modelId: string, modelName: string): void => {
        this.handleModelSelect(providerId, modelId, modelName)
        this.isModelSelectorVisible = false
      },
      onStartEdit: (model: ModelInfo, provider: ModelProvider): void => {
        this.editingModel = model
        this.editingModelProvider = provider
        this.modelSheetActivePanel = 'edit'
      },
      onSaveEdit: async (): Promise<void> => {
        await this.saveModelEdit()
      },
      onCancelEdit: (): void => {
        this.modelSheetActivePanel = 'selector'
        this.editingModel = null
        this.editingModelProvider = null
      }
    })
  }

  private async saveModelEdit(): Promise<void> {
    const providerToSave = this.editingModelProvider
    if (providerToSave !== null) {
      await this.providerViewModel.saveProvider(providerToSave)
      const refreshedProviders = await this.providerViewModel.loadProviders()
      this.providers = refreshedProviders

      for (let i = 0; i < refreshedProviders.length; i++) {
        const provider = refreshedProviders[i]
        if (this.currentProvider !== null && provider.id === this.currentProvider.id) {
          this.currentProvider = provider
          for (let j = 0; j < provider.models.length; j++) {
            const model = provider.models[j]
            if (model.id === this.currentModelId) {
              const modelName = model.name !== '' ? model.name : model.id
              this.currentModel = modelName
              await this.appStateManager.setCurrentModel(model.id, modelName, provider.id)
              break
            }
          }
          break
        }
      }
    }
  }

  @Builder
  AttachmentPickerBuilder() {
    AttachmentPicker({
      onSelectAttachments: (attachments: MessageAttachment[]): void => {
        this.handleAttachmentsSelected(attachments)
      },
      onClose: (): void => {
        this.showAttachmentPicker = false
      }
    })
  }

  @Builder
  SharePreviewBuilder() {
    SharePreviewSheet({
      messages: this.shareMessages,
      currentModelId: this.currentModelId,
      onClose: () => {
        this.showSharePreview = false
      }
    })
  }

  // å¤„ç†é™„ä»¶é€‰æ‹©
  private handleAttachmentsSelected(attachments: MessageAttachment[]): void {
    // æ™®é€šè¾“å…¥æ¨¡å¼ï¼šæ·»åŠ åˆ°è¾“å…¥æ¡†çš„é™„ä»¶åˆ—è¡¨
    for (let i = 0; i < attachments.length; i++) {
      this.pendingAttachments.push(attachments[i])
    }
    // è§¦å‘æ•°ç»„æ›´æ–°ï¼Œä¾¿äºå­ç»„ä»¶ç›‘å¬å¹¶é©±åŠ¨å‘é€æŒ‰é’®åŠ¨æ•ˆ
    this.pendingAttachments = [...this.pendingAttachments]
    this.showAttachmentPicker = false

  }

  private onAppInBackgroundChanged(): void {
    // åå°åˆ‡æ¢ç”±ä»»åŠ¡è°ƒåº¦å™¨ä¸åå°å®ˆæŠ¤æœåŠ¡å¤„ç†ï¼Œè¿™é‡Œåªä¿ç•™æ—¥å¿—
    console.info('ChatPage', `[onAppInBackgroundChanged] appInBackground=${this.appInBackground}`)
  }

  private calcIsAwaitingAiOutput(): boolean {
    if (!this.isSending) {
      return false
    }

    const total = this.messageDataSource.totalCount()
    if (total <= 0) {
      return true
    }

    // ä»å°¾éƒ¨å‘å‰æ‰¾æœ€è¿‘ä¸€æ¡ AI æ¶ˆæ¯ï¼›è‹¥ AI è¿˜æ²¡å¼€å§‹è¾“å‡ºï¼ˆå†…å®¹ä¸ºç©ºï¼‰ï¼Œåˆ™è®¤ä¸ºå¤„äºç­‰å¾…æ€
    for (let i = total - 1; i >= 0; i--) {
      const msg = this.messageDataSource.getData(i)
      if (msg.role === MessageRole.ASSISTANT) {
        return msg.isGenerating && msg.content.length === 0 && msg.reasoningContent.length === 0
      }
      if (msg.role === MessageRole.USER) {
        break
      }
    }

    return true
  }

  // å¤„ç†è¿”å›æŒ‰é’®ç‚¹å‡»
  private handleBack(): void {
    this.navPathStack.pop()
  }

  private safePushUrl(url: string, params?: Object): void {
    try {
      if (params !== undefined) {
        this.getUIContext().getRouter().pushUrl({ url: url, params: params })
      } else {
        this.getUIContext().getRouter().pushUrl({ url: url })
      }
    } catch (error) {
      console.error('ChatPage', `Router pushUrl failed: ${JSON.stringify(error)}`)
    }
  }

  private safeStopInputSession(): void {
    try {
      const inputMethodController = inputMethod.getController()
      inputMethodController.stopInputSession()
    } catch (error) {
      console.error('ChatPage', `Stop input session failed: ${JSON.stringify(error)}`)
    }
  }

  // px è½¬ vp
  private px2vp(px: number): number {
    return px / (this.getUIContext().getHostContext()?.resourceManager.getDeviceCapabilitySync().screenDensity ?? 3) *
      160
  }

  private shouldShowScrollToTopButton(): boolean {
    return shouldShowScrollToTopButtonForChat(this.isMultiSelectMode, this.messageDataSource.totalCount(), this.isAtTop)
  }

  private handleMessageListDidScroll(scrollOffset: number, scrollState: ScrollState): void {
    this.getScrollUiFlow().handleMessageListDidScroll(scrollOffset, scrollState)
  }

  private hasDraftContent(): boolean {
    return this.inputText.trim() !== '' || this.pendingAttachments.length > 0
  }

  // è®¡ç®—åˆ—è¡¨åº•éƒ¨ç•™ç™½é«˜åº¦ï¼ˆéœ€è¦æ ¹æ®è¾“å…¥æ å®é™…é«˜åº¦åŠ¨æ€è°ƒæ•´ï¼‰
  private getListBottomPadding(): number {
    return getListBottomPaddingForChat(this.pendingAttachments.length, this.isEditingMessage,
      this.px2vp(this.bottomAvoidHeight))
  }

  // è·å–é¢„è§ˆæ°”æ³¡çš„æ—¶é—´æ–‡æœ¬
  private getPreviewTimeText(): string {
    return getPreviewTimeTextForChat(new Date())
  }

  // è¾“å…¥å†…å®¹å˜åŒ–æ—¶ï¼Œè‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨æ˜¾ç¤ºé¢„è§ˆæ°”æ³¡
  private onDraftContentChanged(): void {
    this.getScrollUiFlow().onDraftContentChanged()
  }

  // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆå¸¦åŠ¨ç”»è¿‡æ¸¡ï¼‰
  private scrollToBottomWithAnimation(): void {
    this.getScrollUiFlow().scrollToBottomWithAnimation()
  }

  // æ»šåŠ¨åˆ°é¡¶éƒ¨
  private scrollToTopWithAnimation(): void {
    this.getScrollUiFlow().scrollToTopWithAnimation()
  }

  // åŒæ­¥åŒ…è£…æ–¹æ³•ï¼Œç”¨äº onSend å›è°ƒ
  handleSend(): void {
    this.sendMessage()
  }

  // å¤„ç†åœæ­¢ç”Ÿæˆ
  handleStop(): void {
    this.getStopFlow().stopCurrentTask()
  }

  // å¤„ç†æ¨¡å‹é€‰æ‹©
  handleModelSelect(providerId: string, modelId: string, modelName: string): void {
    // æ›´æ–°å½“å‰æ¨¡å‹
    this.currentModel = modelName
    this.currentModelId = modelId
    this.appStateManager.setCurrentModel(modelId, modelName, providerId)

    // æ›´æ–°å½“å‰æœåŠ¡å•†
    for (let i = 0; i < this.providers.length; i++) {
      if (this.providers[i].id === providerId) {
        this.currentProvider = this.providers[i]
        break
      }
    }

    // å…³é—­æ¨¡å‹é€‰æ‹©å™¨
    this.isModelSelectorVisible = false

    this.showChatSnack($r('app.string.model_switched'), 2000, SnackBarTone.SUCCESS)
  }

  async sendMessage(): Promise<void> {
    const prepareResult = this.getSendFlow().prepareSendRequest(
      this.inputText,
      this.pendingAttachments.length,
      this.isSending,
      this.currentProvider,
      this.chatTaskOrchestrator.canStartNewTask()
    )
    if (!prepareResult.shouldSend || prepareResult.currentProvider === null) {
      return
    }
    const messageContent = prepareResult.messageContent
    const currentProvider = prepareResult.currentProvider
    const effectiveApiKey = prepareResult.effectiveApiKey

    await this.refreshToolAvailabilityFromPreferences(false)

    const attachmentsToSend = [...this.pendingAttachments]
    const forcedToolIds = [...this.forcedToolIdsOnce]
    const dispatchResult = await this.getSendFlow().trySendWithFunctionCalling(
      messageContent,
      currentProvider,
      effectiveApiKey,
      attachmentsToSend,
      forcedToolIds,
      this.webSearchAvailable && this.webSearchEnabled,
      this.weatherQueryEnabled,
      this.currentModelId,
      (content: string, attachments: MessageAttachment[]): void => {
        console.info('ChatPage', '[è”ç½‘æŸ¥è¯¢] å½“å‰æ¨¡å‹æœªå¯ç”¨/ä¸æ”¯æŒ toolsï¼Œä½¿ç”¨æ‰‹åŠ¨æœç´¢é“¾è·¯')
        this.getManualSearchFlow().startManualSearchFallback(content, attachments)
      },
      (): void => {
        this.showError($r('app.string.function_calling_not_supported'))
      }
    )
    if (dispatchResult !== ChatSendDispatchResult.NOT_HANDLED) {
      this.forcedToolIdsOnce = []
      return
    }

    this.forcedToolIdsOnce = []
    await this.getSendFlow().sendPlainMessage(
      messageContent,
      currentProvider,
      effectiveApiKey,
      attachmentsToSend
    )
  }

  // å¤„ç†é‡æ–°ç”Ÿæˆï¼ˆæ”¯æŒéæœ€åä¸€æ¡æ¶ˆæ¯ï¼Œæ”¯æŒç”¨æˆ·æ¶ˆæ¯å’Œ AI æ¶ˆæ¯ï¼‰
  async handleRegenerate(message: ChatMessage): Promise<void> {
    if (this.isSending) {
      return
    }
    const userMsgIndex = resolveUserMessageIndexForRegenerate(this.messages, message)
    if (userMsgIndex < 0) {
      return
    }
    const userMsg = this.messages[userMsgIndex]
    const savedContent = userMsg.content
    const savedAttachments = userMsg.attachments.slice()
    const isFirstRound = userMsgIndex === 0
    const messageIdsToDelete = collectTailMessageIds(this.messages, userMsgIndex)
    await this.chatViewModel.deleteMessagesFromIndex(messageIdsToDelete)
    this.messages.splice(userMsgIndex)
    this.messageDataSource.setAllMessages(this.messages)
    this.syncMessagesFromDataSource()
    if (isFirstRound) {
      this.titleGenerateFailed = false
    }
    this.inputText = savedContent
    this.pendingAttachments = savedAttachments
    this.handleSend()
  }

  showError(message: string | Resource): void {
    this.showChatSnack(message, 3000, SnackBarTone.ERROR)
  }

  // ä» messageDataSource åŒæ­¥æ•°æ®åˆ° messages æ•°ç»„ï¼ˆåˆ›å»ºå‰¯æœ¬ï¼Œé¿å…å…±äº«å¼•ç”¨ï¼‰
  private syncMessagesFromDataSource(): void {
    const allMessages = this.messageDataSource.getAllMessages()
    this.messages = []
    for (let i = 0; i < allMessages.length; i++) {
      this.messages.push(allMessages[i])
    }
  }

  // å¤„ç†åˆ é™¤æ¶ˆæ¯
  async handleDeleteMessage(message: ChatMessage): Promise<void> {
    const index = findMessageIndexById(this.messages, message.id)
    if (index < 0) {
      return
    }
    this.messages.splice(index, 1)
    this.messageDataSource.setAllMessages(this.messages)
    this.syncMessagesFromDataSource()
    await this.chatViewModel.deleteMessage(message.id)
    this.showChatSnack($r('app.string.message_deleted'), 2000, SnackBarTone.SUCCESS)
  }

  // å¤„ç†ç¿»è¯‘è¯·æ±‚
  handleTranslate(content: string, targetLang: string, callback: (result: string, errorMessage: string) => void): void {
    this.aiTaskService.translateText(content, targetLang).then((result) => {
      if (result.success) {
        callback(result.content, '')
      } else {
        callback('', result.errorMessage)
      }
    }).catch((error: Error) => {
      callback('', 'ç¿»è¯‘å¤±è´¥ï¼š' + error.message)
    })
  }

  // å¤„ç†TTSæœ—è¯»
  private handleTTS(messageId: string, content: string): void {
    // å¦‚æœæ­£åœ¨æœ—è¯»å…¶ä»–æ¶ˆæ¯ï¼Œå…ˆåœæ­¢
    if (this.speakingMessageId !== '') {
      this.ttsService.stop()
    }

    this.speakingMessageId = messageId

    this.ttsService.speak(content, {
      onStart: () => {
        // æœ—è¯»å¼€å§‹
      },
      onComplete: () => {
        // æœ—è¯»å®Œæˆ
        this.speakingMessageId = ''
      },
      onError: (error: string) => {
        this.speakingMessageId = ''
        this.showChatSnack(error, 3000, SnackBarTone.ERROR)
      }
    })
  }

  // å¤„ç†åœæ­¢TTSæœ—è¯»
  private handleTTSStop(): void {
    this.ttsService.stop()
    this.speakingMessageId = ''
  }

  // å¤„ç†æ–°å»ºå¯¹è¯
  private async handleNewChat(): Promise<void> {
    // åˆ›å»ºæ–°ä¼šè¯
    const session = await this.chatViewModel.createNewSession()
    // æ¸…ç©ºå½“å‰æ¶ˆæ¯
    this.messages = []
    this.messageDataSource.clear()
    // æ›´æ–°ä¼šè¯IDå’Œæ ‡é¢˜
    this.sessionId = session.id
    this.sessionTitle = session.title
    // é‡ç½®æ ‡é¢˜çŠ¶æ€
    this.isTitleGenerating = false
    this.titleGenerateFailed = false
    // æ ‡è®°ä¸ºæ–°å»ºçš„ç©ºä¼šè¯ï¼ˆè¿”å›æ—¶éœ€è¦åˆ é™¤ï¼‰
    this.isNewEmptySession = true

    this.showChatSnack($r('app.string.chat_created'), 2000, SnackBarTone.SUCCESS)
  }

  // å¤„ç†é‡æ–°ç”Ÿæˆæ ‡é¢˜
  private handleRegenerateTitle(): void {
    if (this.messages.length === 0) {
      this.showChatSnack($r('app.string.chat_empty'), 2000, SnackBarTone.ERROR)
      return
    }
    this.titleGenerateFailed = false
    this.showChatSnack($r('app.string.generating_title'), 2000)
    this.chatViewModel.regenerateTitle()
  }

  // å¤„ç†åˆ é™¤å¯¹è¯
  private handleDeleteChat(): void {
    this.getUIContext().showAlertDialog({
      title: $r('app.string.delete_chat'),
      message: $r('app.string.delete_session_confirm'),
      primaryButton: {
        value: $r('app.string.cancel'),
        action: () => {
          // å–æ¶ˆ
        }
      },
      secondaryButton: {
        value: $r('app.string.delete'),
        fontColor: $r('app.color.status_error'),
        action: async () => {
          await this.chatViewModel.deleteSession(this.sessionId)
          this.navPathStack.pop()
        }
      }
    })
  }

  // å¤„ç†ä¿å­˜ç¼–è¾‘çš„æ ‡é¢˜
  private async handleSaveTitle(newTitle: string): Promise<void> {
    if (newTitle.trim() === '') {
      return
    }
    await this.chatViewModel.updateSessionTitle(newTitle.trim())
    this.sessionTitle = newTitle.trim()
    this.showChatSnack($r('app.string.title_updated'), 2000, SnackBarTone.SUCCESS)
  }

  // ========== å¤šé€‰æ¨¡å¼ç›¸å…³æ–¹æ³• ==========

  // ç‚¹å‡»é˜²æŠ–æ ‡å¿—
  private isProcessingMessageClick: boolean = false

  // ç¼–è¾‘æ¶ˆæ¯ï¼šè¿›å…¥å†…è”ç¼–è¾‘æ¨¡å¼
  private async handleEditMessage(message: ChatMessage): Promise<void> {
    this.editingOriginalContent = message.content
    this.editingOriginalAttachments = [...message.attachments]
    this.editingMessageId = message.id
    this.editingMessageIsUser = message.role === MessageRole.USER
    this.inputText = message.content
    this.pendingAttachments = [...message.attachments]
    if (message.role === MessageRole.USER) {
      this.editingWebSearchEnabled = message.searchQuery !== undefined && message.searchQuery !== ''
    }
    this.isEditingMessage = true
    this.getScrollUiFlow().setInputBarVisible(true)
    this.autoFocusInput = true
    await new Promise<void>((resolve) => {
      setTimeout(() => {
        resolve()
      }, 100)
    })
    const messageIndex = findMessageIndexById(this.messages, message.id)
    if (messageIndex >= 0) {
      this.scroller.scrollToIndex(toListScrollIndexForMessage(messageIndex), true, ScrollAlign.CENTER)
    }
  }

  // ========== å†…è”ç¼–è¾‘æ¨¡å¼ç›¸å…³æ–¹æ³• ==========

  // å–æ¶ˆç¼–è¾‘
  private handleCancelEdit(): void {
    // æ¢å¤åŸå§‹å†…å®¹
    this.inputText = ''
    this.pendingAttachments = []

    // é€€å‡ºç¼–è¾‘æ¨¡å¼
    this.isEditingMessage = false
    this.editingMessageId = ''
    this.editingOriginalContent = ''
    this.editingOriginalAttachments = []
    this.editingWebSearchEnabled = false
    this.editingReasoningLevel = ReasoningLevel.OFF
  }

  // å†…è”ç¼–è¾‘æ¨¡å¼ï¼šä¿å­˜å¹¶å‘é€
  private async handleSaveAndSendInline(): Promise<void> {
    await this.getInlineEditFlow().saveAndSendInline(
      this.editingMessageId,
      this.inputText,
      this.pendingAttachments,
      this.editingWebSearchEnabled,
      this.editingReasoningLevel
    )
  }

  // åˆ†äº«å•æ¡æ¶ˆæ¯ï¼šè¿›å…¥å¤šé€‰æ¨¡å¼å¹¶è§¦å‘åˆ†äº«
  private handleShareSingleMessage(message: ChatMessage): void {
    this.getSelectionFlow().enterModeWithMessage(message.id)
    this.handleShareSelectedMessages()
  }

  // è¿›å…¥å¤šé€‰æ¨¡å¼
  private handleEnterMultiSelectMode(messageId: string): void {
    this.getSelectionFlow().enterModeWithMessage(messageId)
  }

  // é€€å‡ºå¤šé€‰æ¨¡å¼
  private handleExitMultiSelectMode(): void {
    this.getSelectionFlow().exitMode()
  }

  // åˆ‡æ¢æ¶ˆæ¯é€‰ä¸­çŠ¶æ€ï¼ˆå¸¦é˜²æŠ–ï¼‰
  private handleToggleMessageSelection(messageId: string): void {
    // é˜²æ­¢é‡å¤ç‚¹å‡»
    if (this.isProcessingMessageClick) {
      return
    }
    this.isProcessingMessageClick = true

    this.selectedMessageIds = this.getSelectionFlow().toggleSelection(this.selectedMessageIds, messageId)

    // 100ms åé‡ç½®æ ‡å¿—
    setTimeout(() => {
      this.isProcessingMessageClick = false
    }, 100)
  }

  // å…¨é€‰/å–æ¶ˆå…¨é€‰
  private handleSelectAllMessages(): void {
    this.selectedMessageIds = this.getSelectionFlow().toggleSelectAll(this.selectedMessageIds)
  }

  // åˆ é™¤é€‰ä¸­çš„æ¶ˆæ¯
  private async handleDeleteSelectedMessages(): Promise<void> {
    if (this.selectedMessageIds.length === 0) {
      return
    }

    this.getUIContext().showAlertDialog({
      title: $r('app.string.delete_messages'),
      message: $r('app.string.delete_selected_messages_confirm'),
      primaryButton: {
        value: $r('app.string.cancel'),
        action: () => {
          // å–æ¶ˆ
        }
      },
      secondaryButton: {
        value: $r('app.string.delete'),
        fontColor: '#FF3B30',
        action: async () => {
          await this.getSelectionFlow().deleteSelectedMessages(this.selectedMessageIds)
        }
      }
    })
  }

  // åˆ†äº«é€‰ä¸­çš„æ¶ˆæ¯
  private handleShareSelectedMessages(): void {
    this.getSelectionFlow().openSharePreview(this.selectedMessageIds)
  }
}

@Builder
export function ChatPageBuilder(name: string, param: Object) {
  ChatPage({ routeParams: param as ChatPageRouteParams })
}
