import { MarkdownController } from '@luvi/lv-markdown-in'
import { hilog } from '@kit.PerformanceAnalysisKit'

const DOMAIN = 0x0002
const TAG = 'MarkdownRenderCache'

// ç¼“å­˜é¡¹
interface CacheItem {
  controller: MarkdownController
  lastAccessTime: number
  contentHash: string
  isDarkMode: boolean
}

// ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
interface CacheStats {
  size: number
  maxSize: number
}

/**
 * Markdown æ¸²æŸ“ç¼“å­˜ç®¡ç†å™¨
 * ä½¿ç”¨ LRU ç­–ç•¥ç¼“å­˜ MarkdownController å®ä¾‹ï¼Œé¿å…é‡å¤åˆ›å»ºå’Œæ¸²æŸ“
 */
export class MarkdownRenderCacheManager {
  // å•ä¾‹å®ä¾‹
  private static instance: MarkdownRenderCacheManager | null = null

  // ç¼“å­˜æ˜ å°„ï¼škey = "contentHash_isDarkMode"
  private cache: Map<string, CacheItem> = new Map<string, CacheItem>()

  // æœ€å¤§ç¼“å­˜æ•°é‡
  private readonly MAX_CACHE_SIZE: number = 50

  // å½“å‰æ·±è‰²æ¨¡å¼çŠ¶æ€ï¼ˆç”¨äºç”Ÿæˆç¼“å­˜é”®ï¼‰
  private currentIsDarkMode: boolean = false

  private constructor() {
    hilog.info(DOMAIN, TAG, 'ğŸš€ MarkdownRenderCacheManager åˆå§‹åŒ–')
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): MarkdownRenderCacheManager {
    if (MarkdownRenderCacheManager.instance === null) {
      MarkdownRenderCacheManager.instance = new MarkdownRenderCacheManager()
    }
    return MarkdownRenderCacheManager.instance
  }

  /**
   * æ›´æ–°å½“å‰æ·±è‰²æ¨¡å¼çŠ¶æ€
   * åœ¨æ·±è‰²æ¨¡å¼åˆ‡æ¢æ—¶è°ƒç”¨ï¼Œç”¨äºç”Ÿæˆæ­£ç¡®çš„ç¼“å­˜é”®
   */
  updateDarkModeState(isDarkMode: boolean): void {
    if (this.currentIsDarkMode !== isDarkMode) {
      hilog.info(DOMAIN, TAG, 'ğŸŒ“ æ·±è‰²æ¨¡å¼çŠ¶æ€æ›´æ–°: %{public}s -> %{public}s',
        this.currentIsDarkMode ? 'æ·±è‰²' : 'æµ…è‰²', isDarkMode ? 'æ·±è‰²' : 'æµ…è‰²')
      this.currentIsDarkMode = isDarkMode
    }
  }

  /**
   * ç”Ÿæˆå†…å®¹å“ˆå¸Œï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨å†…å®¹é•¿åº¦å’Œéƒ¨åˆ†å­—ç¬¦ç”Ÿæˆï¼‰
   * å®Œæ•´å“ˆå¸Œå¯ä»¥ä½¿ç”¨ crypto æ¨¡å—ï¼Œä½†è¿™é‡Œä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬æé«˜æ€§èƒ½
   */
  private generateContentHash(content: string): string {
    if (content.length === 0) {
      return 'empty'
    }

    // ä½¿ç”¨å†…å®¹é•¿åº¦ + å‰50å­—ç¬¦ + å50å­—ç¬¦ç”Ÿæˆå“ˆå¸Œ
    const prefix = content.substring(0, 50)
    const suffix = content.length > 100 ? content.substring(content.length - 50) : ''

    let hash = 0
    const hashContent = prefix + suffix + content.length.toString()

    for (let i = 0; i < hashContent.length; i++) {
      const char = hashContent.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // è½¬æ¢ä¸º32ä½æ•´æ•°
    }

    return Math.abs(hash).toString(36)
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”®
   */
  private generateCacheKey(content: string): string {
    const contentHash = this.generateContentHash(content)
    return `${contentHash}_${this.currentIsDarkMode ? 'dark' : 'light'}`
  }

  /**
   * è·å–æˆ–åˆ›å»º MarkdownController
   */
  getController(content: string): MarkdownController {
    const cacheKey = this.generateCacheKey(content)

    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
    if (this.cache.has(cacheKey)) {
      const item = this.cache.get(cacheKey)
      if (item !== undefined) {
        // æ›´æ–°æœ€åè®¿é—®æ—¶é—´
        item.lastAccessTime = Date.now()
        hilog.debug(DOMAIN, TAG, 'âœ… å‘½ä¸­ç¼“å­˜: %{public}s', cacheKey)
        return item.controller
      }
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œåˆ›å»ºæ–°çš„ Controller
    const controller = new MarkdownController()
    const newItem: CacheItem = {
      controller: controller,
      lastAccessTime: Date.now(),
      contentHash: this.generateContentHash(content),
      isDarkMode: this.currentIsDarkMode
    }

    // æ·»åŠ åˆ°ç¼“å­˜
    this.cache.set(cacheKey, newItem)

    // æ£€æŸ¥ç¼“å­˜å¤§å°ï¼Œå¿…è¦æ—¶æ·˜æ±°æ—§ç¼“å­˜
    this.evictIfNeeded()

    hilog.debug(DOMAIN, TAG, 'â• åˆ›å»ºæ–°ç¼“å­˜: %{public}s (å½“å‰ç¼“å­˜æ•°: %{public}d/%{public}d)',
      cacheKey, this.cache.size, this.MAX_CACHE_SIZE)

    return controller
  }

  /**
   * æ£€æŸ¥å¹¶æ·˜æ±°æ—§ç¼“å­˜ï¼ˆLRU ç­–ç•¥ï¼‰
   */
  private evictIfNeeded(): void {
    if (this.cache.size <= this.MAX_CACHE_SIZE) {
      return
    }

    // æ‰¾åˆ°æœ€ä¹…æœªä½¿ç”¨çš„ç¼“å­˜é¡¹
    let oldestKey: string = ''
    let oldestTime: number = Date.now()

    this.cache.forEach((item: CacheItem, key: string) => {
      if (item.lastAccessTime < oldestTime) {
        oldestTime = item.lastAccessTime
        oldestKey = key
      }
    })

    // åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„ç¼“å­˜
    if (oldestKey !== '') {
      this.cache.delete(oldestKey)
      hilog.debug(DOMAIN, TAG, 'ğŸ—‘ï¸ æ·˜æ±°æ—§ç¼“å­˜: %{public}s', oldestKey)
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜ï¼ˆåœ¨æ·±è‰²æ¨¡å¼åˆ‡æ¢æ—¶è°ƒç”¨ï¼‰
   * æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸ä¼šæ¸…ç©ºç¼“å­˜ï¼Œè€Œæ˜¯é€šè¿‡ä¸åŒçš„ç¼“å­˜é”®åŒºåˆ†æ·±è‰²/æµ…è‰²æ¨¡å¼
   */
  clear(): void {
    const size = this.cache.size
    this.cache.clear()
    hilog.info(DOMAIN, TAG, 'ğŸ§¹ ç¼“å­˜å·²æ¸…ç©º (æ¸…é™¤ %{public}d é¡¹)', size)
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): CacheStats {
    const stats: CacheStats = {
      size: this.cache.size,
      maxSize: this.MAX_CACHE_SIZE
    }
    return stats
  }

  /**
   * é¢„çƒ­ç¼“å­˜ï¼ˆå¯é€‰ï¼Œç”¨äºåœ¨åŠ è½½ä¼šè¯æ—¶é¢„å…ˆç¼“å­˜å·²çŸ¥å†…å®¹ï¼‰
   */
  warmUp(contents: string[]): void {
    hilog.info(DOMAIN, TAG, 'ğŸ”¥ å¼€å§‹é¢„çƒ­ç¼“å­˜ (%{public}d é¡¹)', contents.length)
    for (let i = 0; i < contents.length; i++) {
      this.getController(contents[i])
    }
    hilog.info(DOMAIN, TAG, 'âœ… ç¼“å­˜é¢„çƒ­å®Œæˆ')
  }
}

// å¯¼å‡ºå•ä¾‹è·å–æ–¹æ³•
export function getMarkdownRenderCache(): MarkdownRenderCacheManager {
  return MarkdownRenderCacheManager.getInstance()
}
